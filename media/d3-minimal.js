/**
 * D3.js v7 - Minimal build for hierarchy visualizations
 * Contains: hierarchy, tree, partition, links, zoom, force simulation
 */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).d3=t.d3||{})}(this,function(exports){"use strict";

// Selection
function select(selector){return typeof selector==="string"?new Selection([[document.querySelector(selector)]],[document.documentElement]):new Selection([[selector]],root)}
function selectAll(selector){return typeof selector==="string"?new Selection([document.querySelectorAll(selector)],[document.documentElement]):new Selection([selector],root)}
const root=[null];
class Selection{constructor(groups,parents){this._groups=groups;this._parents=parents;this._enter=null}select(selector){return new Selection(this._groups.map(group=>group.map(node=>node?node.querySelector(selector):null)),this._parents)}selectAll(selector){return new Selection(this._groups.map(group=>[].concat(...group.map(node=>node?[...node.querySelectorAll(selector)]:[]))),this._parents)}append(name){return new Selection(this._groups.map((group,gi)=>group.map(node=>{if(!node)return null;const parent=node._parent||node.parentNode||this._parents[gi]||document.querySelector('svg g')||document.querySelector('svg');const ns=name==="svg"?"http://www.w3.org/2000/svg":(parent?.namespaceURI==="http://www.w3.org/2000/svg"?"http://www.w3.org/2000/svg":"http://www.w3.org/1999/xhtml");const child=document.createElementNS(ns,name);if(parent&&parent.appendChild)parent.appendChild(child);child.__data__=node.__data__;return child})),this._parents)}attr(name,value){if(arguments.length===1)return this._groups[0][0]?.getAttribute(name);this._groups.forEach(group=>group.forEach(node=>{if(node&&node.setAttribute){if(typeof value==="function"){node.setAttribute(name,value(node.__data__,0,group))}else{node.setAttribute(name,value)}}}));return this}style(name,value){this._groups.forEach(group=>group.forEach(node=>{if(node&&node.style){if(typeof value==="function"){node.style[name]=value(node.__data__,0,group)}else{node.style[name]=value}}}));return this}text(value){if(arguments.length===0)return this._groups[0][0]?.textContent;this._groups.forEach(group=>group.forEach(node=>{if(node&&'textContent' in node){node.textContent=typeof value==="function"?value(node.__data__,0,group):value}}));return this}html(value){this._groups.forEach(group=>group.forEach(node=>{if(node&&'innerHTML' in node)node.innerHTML=typeof value==="function"?value(node.__data__,0,group):value}));return this}data(data){const dataArray=typeof data==="function"?data():data;const enterGroups=this._groups.map(()=>[]);dataArray.forEach((d,j)=>{enterGroups[0][j]={__data__:d,_parent:this._parents[0]}});const sel=new Selection(this._groups,this._parents);sel._enter=new Selection(enterGroups,this._parents);return sel}enter(){if(this._enter)return this._enter;return this}on(type,listener){this._groups.forEach(group=>group.forEach(node=>{if(node&&node.addEventListener)node.addEventListener(type,function(event){listener.call(this,event,node.__data__)})}));return this}call(fn,...args){fn.apply(null,[this,...args]);return this}each(fn){this._groups.forEach(group=>group.forEach((node,i)=>{if(node)fn.call(node,node.__data__,i,group)}));return this}remove(){this._groups.forEach(group=>group.forEach(node=>{if(node&&node.parentNode)node.parentNode.removeChild(node)}));return this}transition(){return this}duration(){return this}}

// Hierarchy
function hierarchy(data,children){const root=new Node(data);let node,nodes=[root],child,childs,i,n;while(node=nodes.pop()){if((childs=children?children(node.data):node.data.children)&&(n=childs.length)){node.children=new Array(n);for(i=n-1;i>=0;--i){nodes.push(child=node.children[i]=new Node(childs[i]));child.parent=node;child.depth=node.depth+1}}}}
class Node{constructor(data){this.data=data;this.depth=0;this.height=0;this.parent=null;this.value=0}descendants(){const nodes=[];this.eachBefore(node=>nodes.push(node));return nodes}links(){const links=[];this.eachBefore(node=>{if(node.parent)links.push({source:node.parent,target:node})});return links}eachBefore(callback){let node=this,nodes=[node],children,i;while(node=nodes.pop()){callback(node);if(children=node.children){for(i=children.length-1;i>=0;--i){nodes.push(children[i])}}}return this}sum(fn){return this.eachAfter(node=>{let sum=+fn(node.data)||0;if(node.children)for(const c of node.children)sum+=c.value;node.value=sum})}eachAfter(callback){const nodes=[];const next=[];let node=this;nodes.push(node);while(node=nodes.pop()){next.push(node);if(node.children)for(const c of node.children)nodes.push(c)}while(node=next.pop())callback(node);return this}sort(compare){return this.eachBefore(node=>{if(node.children)node.children.sort(compare)})}}
function hierarchy(data){const root=new Node(data);let nodes=[root],node;while(node=nodes.pop()){const children=node.data.children;if(children){node.children=children.map(d=>{const child=new Node(d);child.parent=node;child.depth=node.depth+1;return child});nodes.push(...node.children)}}computeHeight(root);return root}
function computeHeight(node){let height=0;node.eachBefore(n=>{if(n.children){n.height=1+Math.max(...n.children.map(c=>c.height||0))}else{n.height=0}});return node}

// Tree layout
function tree(){let separation=(a,b)=>a.parent===b.parent?1:2;let size=null;let nodeSize=null;function layout(root){const descendants=root.descendants();const n=descendants.length;if(n===0)return root;
// Assign index to each leaf node
let leafIndex=0;const leaves=[];descendants.forEach(d=>{if(!d.children||d.children.length===0){d._leafIndex=leafIndex++;leaves.push(d)}});const totalLeaves=leafIndex||1;
// Compute x (angular position) based on leaf indices
function computeX(node){if(!node.children||node.children.length===0){return node._leafIndex}else{let sum=0;node.children.forEach(c=>{sum+=computeX(c)});return sum/node.children.length}}
descendants.forEach(d=>{d._mid=computeX(d)});
// Map to size
if(size){descendants.forEach(d=>{d.x=(d._mid/totalLeaves)*size[0];d.y=d.depth*(size[1]/(root.height||1))})}else{descendants.forEach(d=>{d.x=d._mid;d.y=d.depth})}
return root}
layout.size=function(x){return arguments.length?(size=x,nodeSize=null,layout):size};layout.separation=function(x){return arguments.length?(separation=x,layout):separation};return layout}

// Partition layout for sunburst
function partition(){let size=[2*Math.PI,100];let round=false;let padding=0;function layout(root){const n=root.descendants().length;root.x0=0;root.y0=0;root.x1=size[0];root.y1=size[1];const dx=size[0],dy=size[1]/(root.height+1);root.eachBefore(node=>{let x0=node.parent?node.parent.x0:0;if(node.parent&&node.parent.children){const siblings=node.parent.children;const total=siblings.reduce((s,c)=>s+(c.value||1),0);let running=0;for(const sib of siblings){const share=(sib.value||1)/total*(node.parent.x1-node.parent.x0);sib.x0=node.parent.x0+running;sib.x1=sib.x0+share;running+=share}}else if(!node.parent){node.x0=0;node.x1=size[0]}node.y0=node.depth*dy;node.y1=(node.depth+1)*dy;if(round){node.x0=Math.round(node.x0);node.x1=Math.round(node.x1);node.y0=Math.round(node.y0);node.y1=Math.round(node.y1)}});return root}
layout.size=function(x){return arguments.length?(size=x,layout):size};layout.round=function(x){return arguments.length?(round=x,layout):round};layout.padding=function(x){return arguments.length?(padding=x,layout):padding};return layout}

// Links
function linkRadial(){let angle=d=>d.x,radius=d=>d.y;function link(d){const sa=angle(d.source),sr=radius(d.source),ta=angle(d.target),tr=radius(d.target);const c0=Math.cos(sa-Math.PI/2),s0=Math.sin(sa-Math.PI/2);const c1=Math.cos(ta-Math.PI/2),s1=Math.sin(ta-Math.PI/2);return"M"+(sr*c0)+","+(sr*s0)+"C"+((sr+tr)/2*c0)+","+((sr+tr)/2*s0)+" "+((sr+tr)/2*c1)+","+((sr+tr)/2*s1)+" "+(tr*c1)+","+(tr*s1)}link.angle=function(x){return arguments.length?(angle=typeof x==="function"?x:()=>x,link):angle};link.radius=function(x){return arguments.length?(radius=typeof x==="function"?x:()=>x,link):radius};return link}
function linkHorizontal(){return function(d){return"M"+d.source.y+","+d.source.x+"C"+(d.source.y+d.target.y)/2+","+d.source.x+" "+(d.source.y+d.target.y)/2+","+d.target.x+" "+d.target.y+","+d.target.x}}

// Zoom
function zoom(){let scaleExtent=[0,Infinity];let listeners={zoom:[]};function zoomed(selection){selection.on("wheel.zoom",wheeled).on("mousedown.zoom",mousedowned)}
function wheeled(event){event.preventDefault();const k=this.__zoom?this.__zoom.k:1;const newK=k*Math.pow(2,-event.deltaY*0.002);this.__zoom={k:Math.max(scaleExtent[0],Math.min(scaleExtent[1],newK)),x:0,y:0};listeners.zoom.forEach(l=>l.call(this,{transform:this.__zoom,sourceEvent:event}))}
function mousedowned(event){if(event.button)return;const start={x:event.clientX,y:event.clientY,zoom:this.__zoom||{k:1,x:0,y:0}};const that=this;function mousemoved(event){const dx=event.clientX-start.x,dy=event.clientY-start.y;that.__zoom={k:start.zoom.k,x:start.zoom.x+dx,y:start.zoom.y+dy};listeners.zoom.forEach(l=>l.call(that,{transform:that.__zoom,sourceEvent:event}))}
function mouseupped(){window.removeEventListener("mousemove",mousemoved);window.removeEventListener("mouseup",mouseupped)}
window.addEventListener("mousemove",mousemoved);window.addEventListener("mouseup",mouseupped)}
zoomed.scaleExtent=function(x){return arguments.length?(scaleExtent=x,zoomed):scaleExtent};zoomed.on=function(type,listener){if(type.startsWith("zoom"))listeners.zoom.push(listener);return zoomed};zoomed.scaleBy=function(selection,k){selection._groups.forEach(g=>g.forEach(node=>{if(node){node.__zoom=node.__zoom||{k:1,x:0,y:0};node.__zoom.k*=k;listeners.zoom.forEach(l=>l.call(node,{transform:node.__zoom}))}}))};zoomed.transform=function(selection,transform){selection._groups.forEach(g=>g.forEach(node=>{if(node){node.__zoom=transform;listeners.zoom.forEach(l=>l.call(node,{transform}))}}))};return zoomed}
const zoomIdentity={k:1,x:0,y:0,translate:function(x,y){return{k:this.k,x:x,y:y}}};

// Force simulation
function forceSimulation(nodes){let alpha=1,alphaMin=0.001,alphaDecay=1-Math.pow(alphaMin,1/300),alphaTarget=0;const forces={};let ticker;const simulation={tick:function(){alpha+=(alphaTarget-alpha)*alphaDecay;Object.values(forces).forEach(f=>f(alpha));nodes.forEach(node=>{if(node.fx!=null)node.x=node.fx;else node.x+=(node.vx||0)*0.5;if(node.fy!=null)node.y=node.fy;else node.y+=(node.vy||0)*0.5;node.vx=(node.vx||0)*0.6;node.vy=(node.vy||0)*0.6});return simulation},alphaTarget:function(x){return arguments.length?(alphaTarget=x,simulation):alphaTarget},restart:function(){if(!ticker)ticker=setInterval(()=>{simulation.tick();if(alpha<alphaMin){clearInterval(ticker);ticker=null}listeners.forEach(l=>l())},20);return simulation},stop:function(){if(ticker){clearInterval(ticker);ticker=null}return simulation},force:function(name,f){return arguments.length>1?(forces[name]=f,simulation):forces[name]},on:function(name,l){listeners.push(l);return simulation}};const listeners=[];nodes.forEach(n=>{n.x=n.x||(Math.random()-0.5)*100;n.y=n.y||(Math.random()-0.5)*100});return simulation}
function forceLink(links){let strength=1,distance=30,id=d=>d.index;function force(alpha){links.forEach(link=>{const source=typeof link.source==="object"?link.source:link.source;const target=typeof link.target==="object"?link.target:link.target;const dx=target.x-source.x||0.01;const dy=target.y-source.y||0.01;const l=Math.sqrt(dx*dx+dy*dy);const s=(l-distance)/l*alpha*strength;source.vx=(source.vx||0)+dx*s;source.vy=(source.vy||0)+dy*s;target.vx=(target.vx||0)-dx*s;target.vy=(target.vy||0)-dy*s})}
force.id=function(x){return arguments.length?(id=x,force):id};force.distance=function(x){return arguments.length?(distance=x,force):distance};return force}
function forceManyBody(){let strength=-30;function force(alpha){const nodes=this?.nodes||[];nodes.forEach(a=>{nodes.forEach(b=>{if(a===b)return;const dx=b.x-a.x||0.01;const dy=b.y-a.y||0.01;const l=dx*dx+dy*dy;const s=strength*alpha/l;a.vx=(a.vx||0)-dx*s;a.vy=(a.vy||0)-dy*s})})}
force.strength=function(x){return arguments.length?(strength=x,force):strength};return force}
function forceCenter(x,y){function force(alpha){const nodes=this?.nodes||[];let sx=0,sy=0;nodes.forEach(n=>{sx+=n.x;sy+=n.y});sx=sx/nodes.length-x;sy=sy/nodes.length-y;nodes.forEach(n=>{n.x-=sx;n.y-=sy})}
return force}
function forceCollide(){let radius=1;function force(alpha){const nodes=this?.nodes||[];nodes.forEach(a=>{nodes.forEach(b=>{if(a===b)return;const dx=b.x-a.x||0.01;const dy=b.y-a.y||0.01;const l=Math.sqrt(dx*dx+dy*dy);const r=radius*2;if(l<r){const s=(r-l)/l*0.5;a.x-=dx*s;a.y-=dy*s;b.x+=dx*s;b.y+=dy*s}})})}
force.radius=function(x){return arguments.length?(radius=typeof x==="function"?x:()=>x,force):radius};return force}

// Drag
function drag(){let listeners={start:[],drag:[],end:[]};function dragged(selection){selection.on("mousedown.drag",mousedowned)}
function mousedowned(event,d){const that=this;listeners.start.forEach(l=>l.call(that,event,d));function mousemoved(e){listeners.drag.forEach(l=>l.call(that,{x:e.clientX,y:e.clientY,sourceEvent:e},d))}
function mouseupped(e){listeners.end.forEach(l=>l.call(that,e,d));window.removeEventListener("mousemove",mousemoved);window.removeEventListener("mouseup",mouseupped)}
window.addEventListener("mousemove",mousemoved);window.addEventListener("mouseup",mouseupped)}
dragged.on=function(type,listener){if(type==="start")listeners.start.push(listener);else if(type==="drag")listeners.drag.push(listener);else if(type==="end")listeners.end.push(listener);return dragged};return dragged}

exports.select=select;exports.selectAll=selectAll;exports.hierarchy=hierarchy;exports.tree=tree;exports.partition=partition;exports.linkRadial=linkRadial;exports.linkHorizontal=linkHorizontal;exports.zoom=zoom;exports.zoomIdentity=zoomIdentity;exports.forceSimulation=forceSimulation;exports.forceLink=forceLink;exports.forceManyBody=forceManyBody;exports.forceCenter=forceCenter;exports.forceCollide=forceCollide;exports.drag=drag;Object.defineProperty(exports,"__esModule",{value:true})});
